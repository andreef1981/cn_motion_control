// custom motion program for SP filter wheel
/****************************************/
open prog 11

Sys.WpKey=$AAAAAAAA	
Gate3[3].Chan[0].CaptFlagSel=3	// select UserFlag as trigger for move until moves
								// this wheel needs a 25 steps after move to center on detent
Sys.WpKey=$0 // Write-protect Gate3 registers disabling writing to hardware registers

// WheelPosCounter contains wheel position value as a CSglobal

local ThisCs;						// Local var for # of CS running program motor has same #
local wheelStepSize = 400.0;		// Local var for motor units in between two positions
local totalPositions = 16;			// Local var for # of wheel positions
local totalSteps = totalPositions*wheelStepSize;
local desiredPosition = DesiredWheelPosition;		// asign local var from csglobal desired position
local desiredCount = floor(desiredPosition/wheelStepSize);	// how many positions to move
local desiredCountFraction =((desiredPosition/wheelStepSize) - desiredCount)*wheelStepSize; // sub positions to move
local posPositions;	// local var for how many positions to move +
local negPositions; // local var for how many positions to move -
local bestDirection; // local var for the best direction (+1 or -1)
local commandedPosition; // local var for how many positions to move absolute
local loopCounter;
local actualPos;
local deltaPos;
local dwellTime = 500,

ThisCs = Ldata.coord;				// Get CS number for which the program is run
Ldata.motor = ThisCs;				// Asign the right motor locally
//FreshlyHomed = 0;

/* Get the current actualPosition and make sure it is within 0 to totalSteps */
actualPos = Coord[ThisCs].CdPos[0] % totalSteps;
if(actualPos<0){
	actualPos += totalSteps;
}
deltaPos = floor(abs(actualPos-desiredPosition)/wheelStepSize);

// decide which way to move factoring in roll over
if(desiredCount >= WheelPosCounter){			
	posPositions = desiredCount - WheelPosCounter;
	negPositions = -1.0*(totalPositions - desiredCount + WheelPosCounter);
	if(posPositions <= abs(negPositions)){
		bestDirection = 1.0;
		commandedPosition = posPositions;
	}		
	else{
		bestDirection = -1.0;
		commandedPosition = abs(negPositions);
	}	
}
if(desiredCount < WheelPosCounter){	
	posPositions = totalPositions - WheelPosCounter + desiredCount;
	negPositions = WheelPosCounter - desiredCount;
	if(posPositions <= abs(negPositions)){
		bestDirection = 1.0;
		commandedPosition = posPositions;
	}
	else{
		bestDirection = -1.0;
		commandedPosition = abs(negPositions);
	}	
}
/*
// decide which way to move factoring in roll over
if(desiredPosition >= actualPos){			
	posPositions = desiredPosition - actualPos;
	negPositions = -1.0*(totalSteps - desiredPosition + actualPos);
	if(posPositions <= abs(negPositions)){
		bestDirection = 1.0;
		commandedPosition = floor(posPositions/wheelStepSize);
	}		
	else{
		bestDirection = -1.0;
		commandedPosition = floor(abs(negPositions)/wheelStepSize);
	}	
}
if(desiredPosition < actualPos){	
	posPositions = totalSteps - actualPos + desiredPosition;
	negPositions = actualPos - desiredPosition;
	if(posPositions <= abs(negPositions)){
		bestDirection = 1.0;
		commandedPosition = floor(posPositions/wheelStepSize);
	}
	else{
		bestDirection = -1.0;
		commandedPosition = floor(abs(negPositions)/wheelStepSize);
	}
}

*/

// moving negative fractions, commanded position needs to be decreased by one.
// if((desiredCountFraction!=0) && (bestDirection==-1.0)){

/*
if((abs(actualPos-desiredPosition)<wheelStepSize) && (desiredCountFraction!=0)){
	commandedPosition = commandedPosition -1.0;
}
*/

// moving positive
if(bestDirection==1){
	// check if we are in a detent position
	if(Motor11UserFlag==1){
	// in detent
		// check if fractional move is required
		if(desiredCountFraction==0){
		// no fractional movement required
			loopCounter = 1;
			while(loopCounter<=commandedPosition) {
				/* If we are not in a detent postion we have to recover without 
				altering the position count
				if((deltaPos % wheelStepSize != 0) && (loopCounter ==1)){
					jog:((wheelStepSize)*bestDirection)^(0);
				}	*/
				
				/* Due to the width of the detent position we have to creep out of 
				it before starting the triggered move. But stop if we reach desired
				position */
				while(Motor11UserFlag==1){
					jog:(bestDirection*1);
				}
	
				/* Now move to the next position. Using jog and detent interrupt makes sure we
				get to the right position withou relying on absolute values*/
				jog:((wheelStepSize+100)*bestDirection)^(0);
		
				// after each move the actual position has to be updated
				actualPos = Coord[ThisCs].CdPos[0] % totalSteps;
				if(actualPos<0){
					actualPos += totalSteps;
				}
				/* dwelling needed to recognize if detent is engaged. This can potetially be 
				removed to increas speed */
	
				dwell(dwellTime);
				if (Motor11UserFlag==1){
					WheelPosCounter = (WheelPosCounter + bestDirection) % totalPositions;
						if(WheelPosCounter<0){
						WheelPosCounter += totalPositions;
						}
				}
				loopCounter +=1;
			}
		}
		else{
		// fractional move required
		
		}
	}
	else{
	// not in detent
	
	}
}





	
	// recover if we are not in a detent position
	if(Motor11UserFlag==0){
		// triggered move to reach next deten
		jog:((wheelStepSize)*bestDirection)^(0);
	}



Checker = commandedPosition;
// use triggered moves to move position by position

Checker=desiredCountFraction;
// do fractional moves for less than one full position
if(deltaPos % wheelStepSize != 0) {
	/* Due to the width of the detent position we have to creep out of 
	it before starting the triggered move. But stop if we reach desired
	position */
	while((Motor11UserFlag==1) && (actualPos!=desiredPosition)){
		rapid;
		inc;
		A(bestDirection*1);
		// after each move the actual position has to be updated
		actualPos = Coord[ThisCs].CdPos[0] % totalSteps;
		if(actualPos<0){
			actualPos += totalSteps;
		}
	}
	
	if(actualPos!=desiredPosition){
	/* Now move to the desired position if we are not there yet.
	If the move is interrupted by detent, increase the position counter by one*/
		rapid;
		abs;
		A(desiredPosition)^(bestDirection*0); // leave posibility of post trigger move
		
		/* dwelling needed to recognize if detent is engaged. This can potetially be 
		removed to increas speed */
		dwell(1000);
		if (Motor11UserFlag==1){
			WheelPosCounter = (WheelPosCounter + bestDirection) % totalPositions;
			if(WheelPosCounter<0){
				WheelPosCounter += totalPositions;
			}
		}
		
		/* Move to the final position if necessary. This has to be done only once because
		otherwise the commandedPositions variable would be bigger than 1. */
		rapid;
		abs;
		A(desiredPosition); 
	}
	actualPos = Coord[ThisCs].CdPos[0] % totalSteps;
	if(actualPos<0){
		actualPos += totalSteps;
	}
}

/* Built in check to see if we are moving the right amount of positions and if the
commanded position is within 10% of the desired position. */

//if((WheelPosCounter!=desiredCount) || (abs(desiredPosition-actualPos)>wheelStepSize*0.1)){
//	disable ThisCs;
	// buy an encoder as we cannot distinguish between not counting detents and lost steps
//}

// reset the trigger flag selection back to home switch
Sys.WpKey=$AAAAAAAA	
Gate3[3].Chan[0].CaptFlagSel=0	
Sys.WpKey=$0

//send0 "m[%d]:isDone\n",Ldata.coord;

//sendall;

close
/****************************************/

