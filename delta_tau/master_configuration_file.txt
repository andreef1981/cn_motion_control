///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// General settings for controller cards
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Sys.WpKey=$AAAAAAAA							// enable writing to hardware registers
Sys.MaxCoords=24

//Global Clock Settings

//////////////////////////////////////////////////////
// ACC24E Card 0 (2 channel, should be master clock //
//////////////////////////////////////////////////////
Gate3[0].PhaseFreq=9035.69;
Gate3[0].PhaseClockDiv=0;											// [0..3] only used if PhaseServoDir = 0 (master)
Gate3[0].ServoClockDiv=3;											// [0..15] only used if PhaseServoDir = 0 (master)
Gate3[0].AdcAmpStrobe=$fffffc;										// $fffffc is default value
Gate3[0].PfmClockDiv=7												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
																	// each PFM clock cycle a 24 bit active phase D command value
																	// is added to 24 bit accumulator; 7->781.25kHz
Gate3[0].EncClockDiv=5												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
Sys.PhaseOverServoPeriod=1/(Gate3[0].ServoClockDiv+1)				// resulting from input above
Sys.ServoPeriod=1000*(Gate3[0].ServoClockDiv+1)/Gate3[0].PhaseFreq	// resulting from input above

////////////////////////////////////////
// ACC24E Card 1 (4 channel)          //
////////////////////////////////////////
Gate3[1].PhaseFreq=9035.69;
Gate3[1].PhaseClockDiv=0;											// [0..3] only used if PhaseServoDir = 0 (master)
Gate3[1].ServoClockDiv=3;											// [0..15] only used if PhaseServoDir = 0 (master)
Gate3[1].AdcAmpStrobe=$fffffc;										// $fffffc is default value
Gate3[1].PfmClockDiv=7												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
																	// each PFM clock cycle a 24 bit active phase D command value
																	// is added to 24 bit accumulator; 7->781.25kHz
Gate3[1].EncClockDiv=5												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
Sys.PhaseOverServoPeriod=1/(Gate3[1].ServoClockDiv+1)				// resulting from input above
Sys.ServoPeriod=1000*(Gate3[1].ServoClockDiv+1)/Gate3[1].PhaseFreq	// resulting from input above

////////////////////////////////////////
// ACC24E Card 2 (4 channel)          //
////////////////////////////////////////
Gate3[2].PhaseFreq=9035.69;
Gate3[2].PhaseClockDiv=0;											// [0..3] only used if PhaseServoDir = 0 (master)
Gate3[2].ServoClockDiv=3;											// [0..15] only used if PhaseServoDir = 0 (master)
Gate3[2].AdcAmpStrobe=$fffffc;										// $fffffc is default value
Gate3[2].PfmClockDiv=7												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
																	// each PFM clock cycle a 24 bit active phase D command value
																	// is added to 24 bit accumulator; 7->781.25kHz
Gate3[2].EncClockDiv=5												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
Sys.PhaseOverServoPeriod=1/(Gate3[2].ServoClockDiv+1)				// resulting from input above
Sys.ServoPeriod=1000*(Gate3[2].ServoClockDiv+1)/Gate3[2].PhaseFreq	// resulting from input above

////////////////////////////////////////
// ACC24E Card 3 (4 channel)          //
////////////////////////////////////////
Gate3[3].PhaseFreq=9035.69;
Gate3[3].PhaseClockDiv=0;											// [0..3] only used if PhaseServoDir = 0 (master)
Gate3[3].ServoClockDiv=3;											// [0..15] only used if PhaseServoDir = 0 (master)
Gate3[3].AdcAmpStrobe=$fffffc;										// $fffffc is default value
Gate3[3].PfmClockDiv=7												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
																	// each PFM clock cycle a 24 bit active phase D command value
																	// is added to 24 bit accumulator; 7->781.25kHz
Gate3[3].EncClockDiv=5												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
Sys.PhaseOverServoPeriod=1/(Gate3[3].ServoClockDiv+1)				// resulting from input above
Sys.ServoPeriod=1000*(Gate3[3].ServoClockDiv+1)/Gate3[3].PhaseFreq	// resulting from input above

////////////////////////////////////////
// ACC24E Card 4 (4 channel)          //
////////////////////////////////////////
Gate3[4].PhaseFreq=9035.69;
Gate3[4].PhaseClockDiv=0;											// [0..3] only used if PhaseServoDir = 0 (master)
Gate3[4].ServoClockDiv=3;											// [0..15] only used if PhaseServoDir = 0 (master)
Gate3[4].AdcAmpStrobe=$fffffc;										// $fffffc is default value
Gate3[4].PfmClockDiv=7												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
																	// each PFM clock cycle a 24 bit active phase D command value
																	// is added to 24 bit accumulator; 7->781.25kHz
Gate3[4].EncClockDiv=5												// [0..15] default 5 -> 100MHz/2^5 = 3.125 MHz
Sys.PhaseOverServoPeriod=1/(Gate3[4].ServoClockDiv+1)				// resulting from input above
Sys.ServoPeriod=1000*(Gate3[4].ServoClockDiv+1)/Gate3[4].PhaseFreq	// resulting from input above


//////////////////////////////////////////////////////////////
// MOTOR 6 linear lamp stage
//////////////////////////////////////////////////////////////

//Channel PFM Hardware Settings

Gate3[1].Chan[3].PfmWidth=15				// Channel pulse-frequency-modulation output
											// pulse width (software reference manual p. 322)
											// units of pfm cycles; default 15
											
Gate3[1].Chan[3].OutputMode=8				// Servo IC channel output mode select; default=0
											// .outputMode=8 PFM on channel D
											// (software reference manual p. 314)
											
Gate3[1].Chan[3].PackOutData=0				// IC channel PWM/DAC “pack” enable; default=1
											// .PackOutData=0 no packaging all in seperate 
											// registers (software reference manual p. 317)
											
Gate3[1].Chan[3].OutputPol=0    			// IC channel phase output inversion control
											// default=0, range 0to3
											// (software reference manual p. 315)
											
Gate3[1].Chan[3].PfmDirPol=0    			// IC channel PFM direction polarity control
											// default=0 range 0ro1
											// (software reference manual p. 320)
											
Gate3[1].Chan[3].TimerMode=3				// IC Channel encoder timer control; default=0
											// .TimerMode=0 mu's are set by quadrature encoder
											// .TimerMode=3 internal puls and direction drive
											// channels timer circuit as counter leaves encoder
											// counter available for external signal 
											// (software reference manual p. 331)

Gate3[1].Chan[3].EncCtrl=8					// IC channel encoder decode control; default 7; 
											// range 0to15, how to decode input signal,
											//.EncCtrl=7 mu's are set by quadrature encoder 
											// (x4 quadrature decode CW)
											// .EncCtrl=7 mu's are set by quadrature encoder (x4
											// quadrature decode CCW
											// .EncCtrl=8 internal puls and direction CW
											// (software reference manual p. 306)
	
Gate3[1].Chan[3].CaptCtrl=2				// IC Channel position-capture control, default=1
											// range 0to15
											// 1 capture on index high
											// 2 capture on flag high
											// 10 capture on flag low
											// (software reference manual p. 304)

//Encoder Conversion Table

EncTable[6].Type = 1									// Encoder table entry conversion method
														// default=auto based on hardware
														// range 0to15
														// .Type=1 Single-word (32-bit) read
														// (software reference manual p. 209)

EncTable[6].pEnc =  Gate3[1].Chan[3].TimerA.a		// Encoder table entry primary source address
														// The typical addresses used depend on the 
														// conversion type. For type 1
														// .pEnc=Gate3[2].Chan[2].ServoCapt.a For a
														// PMAC3-style ASIC channel’s encoder counter
														// value with hardware interpolation from either
														// timer data (1/T) used with encoder
														// .pEnc =  Gate3[1].Chan[3].TimerA.a for internal
														// feedback loop with PFM signal no encoder
														// (software reference manual p. 199)

EncTable[6].index1 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 left shift of 32 bit
														// register
														// (software reference manual p. 185)

EncTable[6].index2 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 right shift of 32 bit
														// register
														// (software reference manual p. 188)

EncTable[6].index3 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 derivative
														// (software reference manual p. 191)

EncTable[6].index4 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 integrations if index2
														// > 32
														// (software reference manual p. 193)

EncTable[6].MaxDelta = 0								// Encoder table entry maximum legal output change
														// type specific. For type 1 if derivative limiting
														// is enabled. .MaxDelta=0 disabled
														// (software reference manual p. 197)

EncTable[6].ScaleFactor = 1/256							// Encoder table entry output scale factor
														// type 1: (single-word read): After the two shifting
														// operations specified by index2 and index1, the LSB 
														// of the actual data is typically in Bit (32 minus 
														// number of bits) of the 32-bit word. Since most users
														// want the output to be in units of LSBs of actual
														// data, this intermediate result must be multiplied
														// by 2-(32-[# of bits]). For example, if there were
														// 20 bits of real data, ScaleFactor should be set to
														// 2-(32-20), or 2-12, which is 0.00244140625.
														// (software reference manual p. 205)
														// To get the output of the conversion table in units
														// of encodre counts (most common),
														// EncTable[n].ScaleFactor should be set to 1/256 with 
														// encoder and 1.0 without encoder
														// (ACC24E reference manual p. 36 and 114)

//Motor Control

Motor[6].Ctrl=Sys.ServoCtrl							// Pointer to selected servo loop algorithm
													// default .Ctrl=Sys.ServoCtrl standard PID
													// Sys.PidCtrl very simple but fast
													// Sys.AdaptiveCtrl adaptive PID
													// Sys.PosCtrl just positon output no PID
													// (software reference manual p. 370)

Motor[6].PhaseCtrl=0								// Control flag to activate commutation tasks,
													// default=0 range 0to15
													// .PhaseCtrl=0 no phase commutation for steppers
													// (software reference manual p. 422)

Motor[6].ServoCtrl=1								// Control flag to activate servo tasks
													// default=0 range 0to15
													// .ServoCtrl=1 standard servo mode
													// (software reference manual p. 447)

Motor[6].pDac=Gate3[1].Chan[3].Pfm.a				// Command output pointer
													// (software reference manual p. 417)

Motor[6].pAmpFault=Gate3[1].Chan[3].Status.a		// Amplifier-fault (input) flag pointer
													// default=0 disabled
													// pAmpFault = Gate3[m].Chan[n].Status.a to use
													// (software reference manual p. 410)


Motor[6].AmpFaultLevel=1					        // Amplifier-fault level
													// default=0
													// needs to be 1 so that high indicates fault

Motor[6].pAmpEnable=Gate3[1].Chan[3].OutCtrl.a		// Amplifier-enable (output) flag pointer
													// .pAmpEnable=Gate3[1].Chan[3].OutCtrl.a use 
													// .pAmpEnable=1 enable always
													// (software reference manual p. 409)

Motor[6].pLimits = Gate3[1].Chan[3].Status.a		// Overtravel limit (input) flag pointer
													// .pLimits = Gate3[1].Chan[3].Status.a use flags
													// .pLimits = 0 disable flags
													// (software reference manual p. 433)

Motor[6].pCaptFlag = Gate3[1].Chan[3].Status.a		// Encoder capture trigger (input) flag pointer
													// (software reference manual p. 415)

Motor[6].pCaptPos = Gate3[1].Chan[3].HomeCapt.a		// Encoder captured position pointer
													// (software reference manual p. 415)

Motor[6].pEnc = EncTable[6].a						// Outer (position) loop position feedback pointer
													// (software reference manual p. 418)

Motor[6].pEnc2 = EncTable[6].a						// Inner (velocity) loop position feedback pointer
													// (software reference manual p. 418)
													              
// Motor PID servo setup

Motor[6].Servo.Kp = 5.25					// PID proportiona term		
Motor[6].Servo.Ki = 0.00				// PID integral term
Motor[6].Servo.Kvfb= 100					// PID velocity feedback (“derivative”) gain term

Motor[6].Servo.BreakPosErr = 2.0		// Servo gain-break error size (deadband)
Motor[6].Servo.Kbreak = 0				// Servo “gain break” relative gain within this dead band

Motor[6].Servo.MaxPosErr= 1000000.0		// Servo-error input magnitude limit

// Motor Speeds

Motor[6].JogSpeed=15					// Jog command velocity magnitude
										// mu / millisecond
										
Motor[9].MaxSpeed=15

Motor[6].HomeVel=15

Motor[6].JogTa=-200						// Jog accel/decel time or inverse rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^2
										// -200 -> 0.005 mu/ms^2 -> 5m/s^2 or 0.5g

Motor[6].JogTs=-1000					// Jog accel/decel S-curve time or inverse jerk rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^3
										// -50 -> 0.02m/s^3
										// -12500 -> 0.00008 mu/ms^3 -> 80m/s^3 -> 80g/s

Motor[6].BlSize=11605.0					// Backlash size (measured 21 june 2017 by hand at mlimit 8mu steps
										// in mu
										
Motor[6].BlSlewRate =1.0				// Backlash take-up rate
										// mu per servo interrupt
										
Motor[6].HomeOffset=0.0					// Position referencing offset	


// Coordinate system

&6									// Address C.S. 1

#6->1X								// Assign motor to CS and define scale
									// X, Y, Z,.... linear
									// A, B, C, AA, BB, CC .... rotary

//Coord[6].PosRollOver[0]=18000		// Axis position rollover range for rotary only
									// in axis units!!!! default=0.0 disabled
									// .PosRollOver[0] for axis A
									// .PosRollOver[1] for axis B ...
									// 360 -> shortest path in abs move
									// -360 -> use commanded direction in abs move
									
									//////////////////////////////////////////////////////////////
// MOTOR Slit Wheel
//////////////////////////////////////////////////////////////

//Channel PFM Hardware Settings

Gate3[2].Chan[3].PfmWidth=15				// Channel pulse-frequency-modulation output
											// pulse width (software reference manual p. 322)
											// units of pfm cycles; default 15
											
Gate3[2].Chan[3].OutputMode=8				// Servo IC channel output mode select; default=0
											// .outputMode=8 PFM on channel D
											// (software reference manual p. 314)
											
Gate3[2].Chan[3].PackOutData=0				// IC channel PWM/DAC “pack” enable; default=1
											// .PackOutData=0 no packaging all in seperate 
											// registers (software reference manual p. 317)
											
Gate3[2].Chan[3].OutputPol=0    			// IC channel phase output inversion control
											// default=0, range 0to3
											// (software reference manual p. 315)
											
Gate3[2].Chan[3].PfmDirPol=0    			// IC channel PFM direction polarity control
											// default=0 range 0ro1
											// (software reference manual p. 320)
											
Gate3[2].Chan[3].TimerMode=3				// IC Channel encoder timer control; default=0
											// .TimerMode=0 mu's are set by quadrature encoder
											// .TimerMode=3 internal puls and direction drive
											// channels timer circuit as counter leaves encoder
											// counter available for external signal 
											// (software reference manual p. 331)

Gate3[2].Chan[3].EncCtrl=8					// IC channel encoder decode control; default 7; 
											// range 0to15, how to decode input signal,
											//.EncCtrl=7 mu's are set by quadrature encoder 
											// (x4 quadrature decode CW)
											// .EncCtrl=7 mu's are set by quadrature encoder (x4
											// quadrature decode CCW
											// .EncCtrl=8 internal puls and direction CW
											// (software reference manual p. 306)
	
Gate3[2].Chan[3].CaptCtrl=2				// IC Channel position-capture control, default=1
											// range 0to15
											// 1 capture on index high
											// 2 capture on flag high
											// 10 capture on flag low
											// (software reference manual p. 304)

//Encoder Conversion Table

EncTable[10].Type = 1									// Encoder table entry conversion method
														// default=auto based on hardware
														// range 0to15
														// .Type=1 Single-word (32-bit) read
														// (software reference manual p. 209)

EncTable[10].pEnc =  Gate3[2].Chan[3].TimerA.a			// Encoder table entry primary source address
														// The typical addresses used depend on the 
														// conversion type. For type 1
														// .pEnc=Gate3[2].Chan[2].ServoCapt.a For a
														// PMAC3-style ASIC channel’s encoder counter
														// value with hardware interpolation from either
														// timer data (1/T) used with encoder
														// .pEnc =  Gate3[2].Chan[3].TimerA.a for internal
														// feedback loop with PFM signal no encoder
														// (software reference manual p. 199)

EncTable[10].index1 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 left shift of 32 bit
														// register
														// (software reference manual p. 185)

EncTable[10].index2 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 right shift of 32 bit
														// register
														// (software reference manual p. 188)

EncTable[10].index3 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 derivative
														// (software reference manual p. 191)

EncTable[10].index4 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 integrations if index2
														// > 32
														// (software reference manual p. 193)

EncTable[10].MaxDelta = 0								// Encoder table entry maximum legal output change
														// type specific. For type 1 if derivative limiting
														// is enabled. .MaxDelta=0 disabled
														// (software reference manual p. 197)

EncTable[10].ScaleFactor = 1/256							// Encoder table entry output scale factor
														// type 1: (single-word read): After the two shifting
														// operations specified by index2 and index1, the LSB 
														// of the actual data is typically in Bit (32 minus 
														// number of bits) of the 32-bit word. Since most users
														// want the output to be in units of LSBs of actual
														// data, this intermediate result must be multiplied
														// by 2-(32-[# of bits]). For example, if there were
														// 20 bits of real data, ScaleFactor should be set to
														// 2-(32-20), or 2-12, which is 0.00244140625.
														// (software reference manual p. 205)
														// To get the output of the conversion table in units
														// of encodre counts (most common),
														// EncTable[n].ScaleFactor should be set to 1/256 with 
														// encoder and 1/256 without encoder
														// (ACC24E reference manual p. 36 and 114)

//Motor Control

Motor[10].Ctrl=Sys.ServoCtrl							// Pointer to selected servo loop algorithm
													// default .Ctrl=Sys.ServoCtrl standard PID
													// Sys.PidCtrl very simple but fast
													// Sys.AdaptiveCtrl adaptive PID
													// Sys.PosCtrl just positon output no PID
													// (software reference manual p. 370)

Motor[10].PhaseCtrl=0								// Control flag to activate commutation tasks,
													// default=0 range 0to15
													// .PhaseCtrl=0 no phase commutation for steppers
													// (software reference manual p. 422)

Motor[10].ServoCtrl=1								// Control flag to activate servo tasks
													// default=0 range 0to15
													// .ServoCtrl=1 standard servo mode
													// (software reference manual p. 447)

Motor[10].pDac=Gate3[2].Chan[3].Pfm.a				// Command output pointer
													// (software reference manual p. 417)

Motor[10].pAmpFault=Gate3[2].Chan[3].Status.a		// Amplifier-fault (input) flag pointer
													// default=0 disabled
													// pAmpFault = Gate3[m].Chan[n].Status.a to use
													// (software reference manual p. 410)


Motor[10].AmpFaultLevel=1							// Amplifier-fault level
													// default=0
													// needs to be 1 so that high indicates fault

Motor[10].pAmpEnable=Gate3[2].Chan[3].OutCtrl.a		// Amplifier-enable (output) flag pointer
													// .pAmpEnable=Gate3[2].Chan[3].OutCtrl.a use 
													// .pAmpEnable=1 enable always
													// (software reference manual p. 409)

Motor[10].pLimits = 0								// Overtravel limit (input) flag pointer
													// .pLimits = Gate3[2].Chan[3].Status.a use flags
													// .pLimits = 0 disable flags
													// (software reference manual p. 433)

Motor[10].pCaptFlag = Gate3[2].Chan[3].Status.a		// Encoder capture trigger (input) flag pointer
													// (software reference manual p. 415)

Motor[10].pCaptPos = Gate3[2].Chan[3].HomeCapt.a		// Encoder captured position pointer
													// (software reference manual p. 415)

Motor[10].pEnc = EncTable[10].a						// Outer (position) loop position feedback pointer
													// (software reference manual p. 418)

Motor[10].pEnc2 = EncTable[10].a						// Inner (velocity) loop position feedback pointer
													// (software reference manual p. 418)
													              
// Motor PID servo setup

Motor[10].Servo.Kp = 4								// PID proportiona term		
Motor[10].Servo.Ki = 0.001							// PID integral term
Motor[10].Servo.Kvfb= 40							// PID velocity feedback (“derivative”) gain term

Motor[10].Servo.BreakPosErr = 2.0					// Servo gain-break error size (deadband)
Motor[10].Servo.Kbreak = 0							// Servo “gain break” relative gain within this dead band

Motor[10].Servo.MaxPosErr= 1000000.0		// Servo-error input magnitude limit

// Motor Speeds

Motor[10].JogSpeed=0.1					// Jog command velocity magnitude
										// mu / millisecond
Motor[10].HomeVel=0.1

Motor[10].MaxSpeed=0.1

Motor[10].JogTa=-200					// Jog accel/decel time or inverse rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^2
										// -200 -> 0.005 mu/ms^2 -> 5m/s^2 or 0.5g

Motor[10].JogTs=-1000					// Jog accel/decel S-curve time or inverse jerk rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^3
										// -50 -> 0.02m/s^3
										// -12500 -> 0.00008 mu/ms^3 -> 80m/s^3 -> 80g/s

Motor[10].BlSize=0						// Backlash size

Motor[10].BlSlewRate =0.0				// Backlash take-up rate

Motor[10].HomeOffset=0.0					// Position referencing offset	


// Coordinate system

&10									// Address C.S. 1

#10->1A						// Assign motor to CS and define scale
									// X, Y, Z,.... linear
									// A, B, C, AA, BB, CC .... rotary

//Coord[10].PosRollOver[0]=18000		// Axis position rollover range for rotary only
									// in axis units!!!! default=0.0 disabled
									// .PosRollOver[0] for axis A
									// .PosRollOver[1] for axis B ...
									// 360 -> shortest path in abs move
									// -360 -> use commanded direction in abs move
									
									//////////////////////////////////////////////////////////////
// MOTOR Filter Wheel
//////////////////////////////////////////////////////////////

//Channel PFM Hardware Settings

Gate3[3].Chan[0].PfmWidth=15				// Channel pulse-frequency-modulation output
											// pulse width (software reference manual p. 322)
											// units of pfm cycles; default 15
											
Gate3[3].Chan[0].OutputMode=8				// Servo IC channel output mode select; default=0
											// .outputMode=8 PFM on channel D
											// (software reference manual p. 314)
											
Gate3[3].Chan[0].PackOutData=0				// IC channel PWM/DAC “pack” enable; default=1
											// .PackOutData=0 no packaging all in seperate 
											// registers (software reference manual p. 317)
											
Gate3[3].Chan[0].OutputPol=0    			// IC channel phase output inversion control
											// default=0, range 0to3
											// (software reference manual p. 315)
											
Gate3[3].Chan[0].PfmDirPol=0    			// IC channel PFM direction polarity control
											// default=0 range 0ro1
											// (software reference manual p. 320)
											
Gate3[3].Chan[0].TimerMode=3				// IC Channel encoder timer control; default=0
											// .TimerMode=0 mu's are set by quadrature encoder
											// .TimerMode=3 internal puls and direction drive
											// channels timer circuit as counter leaves encoder
											// counter available for external signal 
											// (software reference manual p. 331)

Gate3[3].Chan[0].EncCtrl=8					// IC channel encoder decode control; default 7; 
											// range 0to15, how to decode input signal,
											//.EncCtrl=7 mu's are set by quadrature encoder 
											// (x4 quadrature decode CW)
											// .EncCtrl=7 mu's are set by quadrature encoder (x4
											// quadrature decode CCW
											// .EncCtrl=8 internal puls and direction CW
											// (software reference manual p. 306)
	
Gate3[3].Chan[0].CaptCtrl=2				    // IC Channel position-capture control, default=1
											// range 0to15
											// 1 capture on index high
											// 2 capture on flag high
											// 10 capture on flag low
											// (software reference manual p. 304)

//Encoder Conversion Table

EncTable[11].Type = 1									// Encoder table entry conversion method
														// default=auto based on hardware
														// range 0to15
														// .Type=1 Single-word (32-bit) read
														// (software reference manual p. 209)

EncTable[11].pEnc =  Gate3[3].Chan[0].TimerA.a			// Encoder table entry primary source address
														// The typical addresses used depend on the 
														// conversion type. For type 1
														// .pEnc=Gate3[2].Chan[2].ServoCapt.a For a
														// PMAC3-style ASIC channel’s encoder counter
														// value with hardware interpolation from either
														// timer data (1/T) used with encoder
														// .pEnc =  Gate3[3].Chan[0].TimerA.a for internal
														// feedback loop with PFM signal no encoder
														// (software reference manual p. 199)

EncTable[11].index1 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 left shift of 32 bit
														// register
														// (software reference manual p. 185)

EncTable[11].index2 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 right shift of 32 bit
														// register
														// (software reference manual p. 188)

EncTable[11].index3 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 derivative
														// (software reference manual p. 191)

EncTable[11].index4 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 integrations if index2
														// > 32
														// (software reference manual p. 193)

EncTable[11].MaxDelta = 0								// Encoder table entry maximum legal output change
														// type specific. For type 1 if derivative limiting
														// is enabled. .MaxDelta=0 disabled
														// (software reference manual p. 197)

EncTable[11].ScaleFactor = 1/256							// Encoder table entry output scale factor
														// type 1: (single-word read): After the two shifting
														// operations specified by index2 and index1, the LSB 
														// of the actual data is typically in Bit (32 minus 
														// number of bits) of the 32-bit word. Since most users
														// want the output to be in units of LSBs of actual
														// data, this intermediate result must be multiplied
														// by 2-(32-[# of bits]). For example, if there were
														// 20 bits of real data, ScaleFactor should be set to
														// 2-(32-20), or 2-12, which is 0.00244140625.
														// (software reference manual p. 205)
														// To get the output of the conversion table in units
														// of encodre counts (most common),
														// EncTable[n].ScaleFactor should be set to 1/256 with 
														// encoder and 1.0 without encoder
														// (ACC24E reference manual p. 36 and 114)

//Motor Control

Motor[11].Ctrl=Sys.ServoCtrl							// Pointer to selected servo loop algorithm
													// default .Ctrl=Sys.ServoCtrl standard PID
													// Sys.PidCtrl very simple but fast
													// Sys.AdaptiveCtrl adaptive PID
													// Sys.PosCtrl just positon output no PID
													// (software reference manual p. 370)

Motor[11].PhaseCtrl=0								// Control flag to activate commutation tasks,
													// default=0 range 0to15
													// .PhaseCtrl=0 no phase commutation for steppers
													// (software reference manual p. 422)

Motor[11].ServoCtrl=1								// Control flag to activate servo tasks
													// default=0 range 0to15
													// .ServoCtrl=1 standard servo mode
													// (software reference manual p. 447)

Motor[11].pDac=Gate3[3].Chan[0].Pfm.a				// Command output pointer
													// (software reference manual p. 417)

Motor[11].pAmpFault=Gate3[3].Chan[0].Status.a      	// Amplifier-fault (input) flag pointer
													// default=0 disabled
													// pAmpFault = Gate3[m].Chan[n].Status.a to use
													// (software reference manual p. 410)


Motor[11].AmpFaultLevel=1							// Amplifier-fault level
													// default=0
													// needs to be 1 so that high indicates fault

Motor[11].pAmpEnable=Gate3[3].Chan[0].OutCtrl.a		// Amplifier-enable (output) flag pointer
													// .pAmpEnable=Gate3[3].Chan[0].OutCtrl.a use 
													// .pAmpEnable=1 enable always
													// (software reference manual p. 409)

Motor[11].pLimits = 0								// Overtravel limit (input) flag pointer
													// .pLimits = Gate3[3].Chan[0].Status.a use flags
													// .pLimits = 0 disable flags
													// (software reference manual p. 433)

Motor[11].pCaptFlag = Gate3[3].Chan[0].Status.a		// Encoder capture trigger (input) flag pointer
													// (software reference manual p. 415)

Motor[11].pCaptPos = Gate3[3].Chan[0].HomeCapt.a		// Encoder captured position pointer
													// (software reference manual p. 415)

Motor[11].pEnc = EncTable[11].a						// Outer (position) loop position feedback pointer
													// (software reference manual p. 418)

Motor[11].pEnc2 = EncTable[11].a						// Inner (velocity) loop position feedback pointer
													// (software reference manual p. 418)
													              
// Motor PID servo setup

Motor[11].Servo.Kp = 4					// PID proportiona term		
Motor[11].Servo.Ki = 0.001				// PID integral term
Motor[11].Servo.Kvfb= 40					// PID velocity feedback (“derivative”) gain term

Motor[11].Servo.BreakPosErr = 2.0		// Servo gain-break error size (deadband)
Motor[11].Servo.Kbreak = 0				// Servo “gain break” relative gain within this dead band

Motor[11].Servo.MaxPosErr= 1000000.0	// Servo-error input magnitude limit

// Motor Speeds

Motor[11].JogSpeed=0.1					// Jog command velocity magnitude
										// mu / millisecond
Motor[11].HomeVel=0.1

Motor[11].MaxSpeed=0.1

Motor[11].JogTa=-200					// Jog accel/decel time or inverse rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^2
										// -200 -> 0.005 mu/ms^2 -> 5m/s^2 or 0.5g

Motor[11].JogTs=-1000					// Jog accel/decel S-curve time or inverse jerk rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^3
										// -50 -> 0.02m/s^3
										// -12500 -> 0.00008 mu/ms^3 -> 80m/s^3 -> 80g/s

Motor[11].BlSize=0						// Backlash size

Motor[11].BlSlewRate =0.0				// Backlash take-up rate

Motor[11].HomeOffset=0.0					// Position referencing offset	


// Coordinate system

&11									// Address C.S. 1

#11->1A							// Assign motor to CS and define scale
									// X, Y, Z,.... linear
									// A, B, C, AA, BB, CC .... rotary

//Coord[11].PosRollOver[0]=18000		// Axis position rollover range for rotary only
									// in axis units!!!! default=0.0 disabled
									// .PosRollOver[0] for axis A
									// .PosRollOver[1] for axis B ...
									// 360 -> shortest path in abs move
									// -360 -> use commanded direction in abs move
									
									//////////////////////////////////////////////////////////////
// MOTOR CI filter wheel 1 (front closer to entrance)
//////////////////////////////////////////////////////////////

//Channel PFM Hardware Settings

Gate3[4].Chan[1].PfmWidth=15				// Channel pulse-frequency-modulation output
											// pulse width (software reference manual p. 322)
											// units of pfm cycles; default 15
											
Gate3[4].Chan[1].OutputMode=8				// Servo IC channel output mode select; default=0
											// .outputMode=8 PFM on channel D
											// (software reference manual p. 314)
											
Gate3[4].Chan[1].PackOutData=0				// IC channel PWM/DAC “pack” enable; default=1
											// .PackOutData=0 no packaging all in seperate 
											// registers (software reference manual p. 317)
											
Gate3[4].Chan[1].OutputPol=0    			// IC channel phase output inversion control
											// default=0, range 0to3
											// (software reference manual p. 315)
											
Gate3[4].Chan[1].PfmDirPol=0    			// IC channel PFM direction polarity control
											// default=0 range 0ro1
											// (software reference manual p. 320)
											
Gate3[4].Chan[1].TimerMode=3				// IC Channel encoder timer control; default=0
											// .TimerMode=0 mu's are set by quadrature encoder
											// .TimerMode=3 internal puls and direction drive
											// channels timer circuit as counter leaves encoder
											// counter available for external signal 
											// (software reference manual p. 331)

Gate3[4].Chan[1].EncCtrl=8					// IC channel encoder decode control; default 7; 
											// range 0to15, how to decode input signal,
											//.EncCtrl=7 mu's are set by quadrature encoder 
											// (x4 quadrature decode CW)
											// .EncCtrl=7 mu's are set by quadrature encoder (x4
											// quadrature decode CCW
											// .EncCtrl=8 internal puls and direction CW
											// (software reference manual p. 306)
	
Gate3[4].Chan[1].CaptCtrl=2					// IC Channel position-capture control, default=1
											// range 0to15
											// 1 capture on index high
											// 2 capture on flag high
											// 10 capture on flag low
											// (software reference manual p. 304)

//Encoder Conversion Table

EncTable[16].Type = 1									// Encoder table entry conversion method
														// default=auto based on hardware
														// range 0to15
														// .Type=1 Single-word (32-bit) read
														// (software reference manual p. 209)

EncTable[16].pEnc =  Gate3[4].Chan[1].TimerA.a			// Encoder table entry primary source address
														// The typical addresses used depend on the 
														// conversion type. For type 1
														// .pEnc=Gate3[2].Chan[2].ServoCapt.a For a
														// PMAC3-style ASIC channel’s encoder counter
														// value with hardware interpolation from either
														// timer data (1/T) used with encoder
														// .pEnc =  Gate3[4].Chan[1].TimerA.a for internal
														// feedback loop with PFM signal no encoder
														// (software reference manual p. 199)

EncTable[16].index1 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 left shift of 32 bit
														// register
														// (software reference manual p. 185)

EncTable[16].index2 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 right shift of 32 bit
														// register
														// (software reference manual p. 188)

EncTable[16].index3 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 derivative
														// (software reference manual p. 191)

EncTable[16].index4 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 integrations if index2
														// > 32
														// (software reference manual p. 193)

EncTable[16].MaxDelta = 0								// Encoder table entry maximum legal output change
														// type specific. For type 1 if derivative limiting
														// is enabled. .MaxDelta=0 disabled
														// (software reference manual p. 197)

EncTable[16].ScaleFactor = 1/256							// Encoder table entry output scale factor
														// type 1: (single-word read): After the two shifting
														// operations specified by index2 and index1, the LSB 
														// of the actual data is typically in Bit (32 minus 
														// number of bits) of the 32-bit word. Since most users
														// want the output to be in units of LSBs of actual
														// data, this intermediate result must be multiplied
														// by 2-(32-[# of bits]). For example, if there were
														// 20 bits of real data, ScaleFactor should be set to
														// 2-(32-20), or 2-12, which is 0.00244140625.
														// (software reference manual p. 205)
														// To get the output of the conversion table in units
														// of encodre counts (most common),
														// EncTable[n].ScaleFactor should be set to 1/256 with 
														// encoder and 1.0 without encoder
														// (ACC24E reference manual p. 36 and 114)

//Motor Control

Motor[16].Ctrl=Sys.ServoCtrl							// Pointer to selected servo loop algorithm
													// default .Ctrl=Sys.ServoCtrl standard PID
													// Sys.PidCtrl very simple but fast
													// Sys.AdaptiveCtrl adaptive PID
													// Sys.PosCtrl just positon output no PID
													// (software reference manual p. 370)

Motor[16].PhaseCtrl=0								// Control flag to activate commutation tasks,
													// default=0 range 0to15
													// .PhaseCtrl=0 no phase commutation for steppers
													// (software reference manual p. 422)

Motor[16].ServoCtrl=1								// Control flag to activate servo tasks
													// default=0 range 0to15
													// .ServoCtrl=1 standard servo mode
													// (software reference manual p. 447)

Motor[16].pDac=Gate3[4].Chan[1].Pfm.a				// Command output pointer
													// (software reference manual p. 417)

Motor[16].pAmpFault=Gate3[4].Chan[1].Status.a                  				// Amplifier-fault (input) flag pointer
													// default=0 disabled
													// pAmpFault = Gate3[m].Chan[n].Status.a to use
													// (software reference manual p. 410)


Motor[16].AmpFaultLevel=1					// Amplifier-fault level
													// default=0
													// needs to be 1 so that high indicates fault

Motor[16].pAmpEnable=Gate3[4].Chan[1].OutCtrl.a		// Amplifier-enable (output) flag pointer
													// .pAmpEnable=Gate3[4].Chan[1].OutCtrl.a use 
													// .pAmpEnable=1 enable always
													// (software reference manual p. 409)

Motor[16].pLimits = 0		// Overtravel limit (input) flag pointer
													// .pLimits = Gate3[4].Chan[1].Status.a use flags
													// .pLimits = 0 disable flags
													// (software reference manual p. 433)

Motor[16].pCaptFlag = Gate3[4].Chan[1].Status.a		// Encoder capture trigger (input) flag pointer
													// (software reference manual p. 415)

Motor[16].pCaptPos = Gate3[4].Chan[1].HomeCapt.a		// Encoder captured position pointer
													// (software reference manual p. 415)

Motor[16].pEnc = EncTable[16].a						// Outer (position) loop position feedback pointer
													// (software reference manual p. 418)

Motor[16].pEnc2 = EncTable[16].a						// Inner (velocity) loop position feedback pointer
													// (software reference manual p. 418)
													              
// Motor PID servo setup

Motor[16].Servo.Kp = 4					// PID proportiona term		
Motor[16].Servo.Ki = 0.001				// PID integral term
Motor[16].Servo.Kvfb= 40					// PID velocity feedback (“derivative”) gain term

Motor[16].Servo.BreakPosErr = 2.0		// Servo gain-break error size (deadband)
Motor[16].Servo.Kbreak = 0				// Servo “gain break” relative gain within this dead band

Motor[16].Servo.MaxPosErr= 1000000.0		// Servo-error input magnitude limit

// Motor Speeds

Motor[16].JogSpeed=0.1					// Jog command velocity magnitude
										// mu / millisecond
Motor[16].HomeVel=0.1

Motor[16].MaxSpeed=0.1

Motor[16].JogTa=-200						// Jog accel/decel time or inverse rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^2
										// -200 -> 0.005 mu/ms^2 -> 5m/s^2 or 0.5g

Motor[16].JogTs=-1000					// Jog accel/decel S-curve time or inverse jerk rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^3
										// -50 -> 0.02m/s^3
										// -12500 -> 0.00008 mu/ms^3 -> 80m/s^3 -> 80g/s

Motor[16].BlSize=0						// Backlash size

Motor[16].BlSlewRate =0.0				// Backlash take-up rate

Motor[16].HomeOffset=0.0					// Position referencing offset	


// Coordinate system

&16									// Address C.S. 1

#16->1A						// Assign motor to CS and define scale
									// X, Y, Z,.... linear
									// A, B, C, AA, BB, CC .... rotary

//Coord[16].PosRollOver[0]=18000		// Axis position rollover range for rotary only
									// in axis units!!!! default=0.0 disabled
									// .PosRollOver[0] for axis A
									// .PosRollOver[1] for axis B ...
									// 360 -> shortest path in abs move
									// -360 -> use commanded direction in abs move
									
									//////////////////////////////////////////////////////////////
// MOTOR CI filter wheel 2 (closer to detector)
//////////////////////////////////////////////////////////////

//Channel PFM Hardware Settings

Gate3[4].Chan[2].PfmWidth=15				// Channel pulse-frequency-modulation output
											// pulse width (software reference manual p. 322)
											// units of pfm cycles; default 15
											
Gate3[4].Chan[2].OutputMode=8				// Servo IC channel output mode select; default=0
											// .outputMode=8 PFM on channel D
											// (software reference manual p. 314)
											
Gate3[4].Chan[2].PackOutData=0				// IC channel PWM/DAC “pack” enable; default=1
											// .PackOutData=0 no packaging all in seperate 
											// registers (software reference manual p. 317)
											
Gate3[4].Chan[2].OutputPol=0    			// IC channel phase output inversion control
											// default=0, range 0to3
											// (software reference manual p. 315)
											
Gate3[4].Chan[2].PfmDirPol=0    			// IC channel PFM direction polarity control
											// default=0 range 0ro1
											// (software reference manual p. 320)
											
Gate3[4].Chan[2].TimerMode=3				// IC Channel encoder timer control; default=0
											// .TimerMode=0 mu's are set by quadrature encoder
											// .TimerMode=3 internal puls and direction drive
											// channels timer circuit as counter leaves encoder
											// counter available for external signal 
											// (software reference manual p. 331)

Gate3[4].Chan[2].EncCtrl=8					// IC channel encoder decode control; default 7; 
											// range 0to15, how to decode input signal,
											//.EncCtrl=7 mu's are set by quadrature encoder 
											// (x4 quadrature decode CW)
											// .EncCtrl=7 mu's are set by quadrature encoder (x4
											// quadrature decode CCW
											// .EncCtrl=8 internal puls and direction CW
											// (software reference manual p. 306)
	
Gate3[4].Chan[2].CaptCtrl=2					// IC Channel position-capture control, default=1
											// range 0to15
											// 1 capture on index high
											// 2 capture on flag high
											// 10 capture on flag low
											// (software reference manual p. 304)

//Encoder Conversion Table

EncTable[17].Type = 1									// Encoder table entry conversion method
														// default=auto based on hardware
														// range 0to15
														// .Type=1 Single-word (32-bit) read
														// (software reference manual p. 209)

EncTable[17].pEnc =  Gate3[4].Chan[2].TimerA.a			// Encoder table entry primary source address
														// The typical addresses used depend on the 
														// conversion type. For type 1
														// .pEnc=Gate3[2].Chan[2].ServoCapt.a For a
														// PMAC3-style ASIC channel’s encoder counter
														// value with hardware interpolation from either
														// timer data (1/T) used with encoder
														// .pEnc =  Gate3[4].Chan[2].TimerA.a for internal
														// feedback loop with PFM signal no encoder
														// (software reference manual p. 199)

EncTable[17].index1 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 left shift of 32 bit
														// register
														// (software reference manual p. 185)

EncTable[17].index2 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 right shift of 32 bit
														// register
														// (software reference manual p. 188)

EncTable[17].index3 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 derivative
														// (software reference manual p. 191)

EncTable[17].index4 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 integrations if index2
														// > 32
														// (software reference manual p. 193)

EncTable[17].MaxDelta = 0								// Encoder table entry maximum legal output change
														// type specific. For type 1 if derivative limiting
														// is enabled. .MaxDelta=0 disabled
														// (software reference manual p. 197)

EncTable[17].ScaleFactor = 1/256							// Encoder table entry output scale factor
														// type 1: (single-word read): After the two shifting
														// operations specified by index2 and index1, the LSB 
														// of the actual data is typically in Bit (32 minus 
														// number of bits) of the 32-bit word. Since most users
														// want the output to be in units of LSBs of actual
														// data, this intermediate result must be multiplied
														// by 2-(32-[# of bits]). For example, if there were
														// 20 bits of real data, ScaleFactor should be set to
														// 2-(32-20), or 2-12, which is 0.00244140625.
														// (software reference manual p. 205)
														// To get the output of the conversion table in units
														// of encodre counts (most common),
														// EncTable[n].ScaleFactor should be set to 1/256 with 
														// encoder and 1.0 without encoder
														// (ACC24E reference manual p. 36 and 114)

//Motor Control

Motor[17].Ctrl=Sys.ServoCtrl							// Pointer to selected servo loop algorithm
													// default .Ctrl=Sys.ServoCtrl standard PID
													// Sys.PidCtrl very simple but fast
													// Sys.AdaptiveCtrl adaptive PID
													// Sys.PosCtrl just positon output no PID
													// (software reference manual p. 370)

Motor[17].PhaseCtrl=0								// Control flag to activate commutation tasks,
													// default=0 range 0to15
													// .PhaseCtrl=0 no phase commutation for steppers
													// (software reference manual p. 422)

Motor[17].ServoCtrl=1								// Control flag to activate servo tasks
													// default=0 range 0to15
													// .ServoCtrl=1 standard servo mode
													// (software reference manual p. 447)

Motor[17].pDac=Gate3[4].Chan[2].Pfm.a				// Command output pointer
													// (software reference manual p. 417)

Motor[17].pAmpFault=Gate3[4].Chan[2].Status.a                  				// Amplifier-fault (input) flag pointer
													// default=0 disabled
													// pAmpFault = Gate3[m].Chan[n].Status.a to use
													// (software reference manual p. 410)


Motor[17].AmpFaultLevel=1					// Amplifier-fault level
													// default=0
													// needs to be 1 so that high indicates fault

Motor[17].pAmpEnable=Gate3[4].Chan[2].OutCtrl.a		// Amplifier-enable (output) flag pointer
													// .pAmpEnable=Gate3[4].Chan[2].OutCtrl.a use 
													// .pAmpEnable=1 enable always
													// (software reference manual p. 409)

Motor[17].pLimits = Gate3[4].Chan[2].Status.a		// Overtravel limit (input) flag pointer
													// .pLimits = Gate3[4].Chan[2].Status.a use flags
													// .pLimits = 0 disable flags
													// (software reference manual p. 433)

Motor[17].pCaptFlag = Gate3[4].Chan[2].Status.a		// Encoder capture trigger (input) flag pointer
													// (software reference manual p. 415)

Motor[17].pCaptPos = Gate3[4].Chan[2].HomeCapt.a		// Encoder captured position pointer
													// (software reference manual p. 415)

Motor[17].pEnc = EncTable[17].a						// Outer (position) loop position feedback pointer
													// (software reference manual p. 418)

Motor[17].pEnc2 = EncTable[17].a						// Inner (velocity) loop position feedback pointer
													// (software reference manual p. 418)
													              
// Motor PID servo setup

Motor[17].Servo.Kp = 4					// PID proportiona term		
Motor[17].Servo.Ki = 0.001				// PID integral term
Motor[17].Servo.Kvfb= 40					// PID velocity feedback (“derivative”) gain term

Motor[17].Servo.BreakPosErr = 2.0		// Servo gain-break error size (deadband)
Motor[17].Servo.Kbreak = 0				// Servo “gain break” relative gain within this dead band

Motor[17].Servo.MaxPosErr= 1000000.0		// Servo-error input magnitude limit

// Motor Speeds

Motor[17].JogSpeed=0.1					// Jog command velocity magnitude
										// mu / millisecond
Motor[17].HomeVel=0.1

Motor[17].MaxSpeed=0.1

Motor[17].JogTa=-200						// Jog accel/decel time or inverse rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^2
										// -200 -> 0.005 mu/ms^2 -> 5m/s^2 or 0.5g

Motor[17].JogTs=-1000					// Jog accel/decel S-curve time or inverse jerk rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^3
										// -50 -> 0.02m/s^3
										// -12500 -> 0.00008 mu/ms^3 -> 80m/s^3 -> 80g/s

Motor[17].BlSize=0						// Backlash size

Motor[17].BlSlewRate =0.0				// Backlash take-up rate

Motor[17].HomeOffset=0.0					// Position referencing offset	


// Coordinate system

&17									// Address C.S. 1

#17->1A							// Assign motor to CS and define scale
									// X, Y, Z,.... linear
									// A, B, C, AA, BB, CC .... rotary

//Coord[17].PosRollOver[0]=18000		// Axis position rollover range for rotary only
									// in axis units!!!! default=0.0 disabled
									// .PosRollOver[0] for axis A
									// .PosRollOver[1] for axis B ...
									// 360 -> shortest path in abs move
									// -360 -> use commanded direction in abs move
									
									//////////////////////////////////////////////////////////////
// MOTOR Grating stage
//////////////////////////////////////////////////////////////

//Channel PFM Hardware Settings

Gate3[4].Chan[3].PfmWidth=15				// Channel pulse-frequency-modulation output
											// pulse width (software reference manual p. 322)
											// units of pfm cycles; default 15
											
Gate3[4].Chan[3].OutputMode=8				// Servo IC channel output mode select; default=0
											// .outputMode=8 PFM on channel D
											// (software reference manual p. 314)
											
Gate3[4].Chan[3].PackOutData=0				// IC channel PWM/DAC “pack” enable; default=1
											// .PackOutData=0 no packaging all in seperate 
											// registers (software reference manual p. 317)
											
Gate3[4].Chan[3].OutputPol=0    			// IC channel phase output inversion control
											// default=0, range 0to3
											// (software reference manual p. 315)
											
Gate3[4].Chan[3].PfmDirPol=0    			// IC channel PFM direction polarity control
											// default=0 range 0ro1
											// (software reference manual p. 320)
											
Gate3[4].Chan[3].TimerMode=3				// IC Channel encoder timer control; default=0
											// .TimerMode=0 mu's are set by quadrature encoder
											// .TimerMode=3 internal puls and direction drive
											// channels timer circuit as counter leaves encoder
											// counter available for external signal 
											// (software reference manual p. 331)

Gate3[4].Chan[3].EncCtrl=8					// IC channel encoder decode control; default 7; 
											// range 0to15, how to decode input signal,
											//.EncCtrl=7 mu's are set by quadrature encoder 
											// (x4 quadrature decode CW)
											// .EncCtrl=7 mu's are set by quadrature encoder (x4
											// quadrature decode CCW
											// .EncCtrl=8 internal puls and direction CW
											// (software reference manual p. 306)
	
Gate3[4].Chan[3].CaptCtrl=2					// IC Channel position-capture control, default=1
											// range 0to15
											// 1 capture on index high
											// 2 capture on flag high
											// 10 capture on flag low
											// (software reference manual p. 304)

//Encoder Conversion Table

EncTable[18].Type = 1									// Encoder table entry conversion method
														// default=auto based on hardware
														// range 0to15
														// .Type=1 Single-word (32-bit) read
														// (software reference manual p. 209)

EncTable[18].pEnc =  Gate3[4].Chan[3].TimerA.a			// Encoder table entry primary source address
														// The typical addresses used depend on the 
														// conversion type. For type 1
														// .pEnc=Gate3[2].Chan[2].ServoCapt.a For a
														// PMAC3-style ASIC channel’s encoder counter
														// value with hardware interpolation from either
														// timer data (1/T) used with encoder
														// .pEnc =  Gate3[4].Chan[3].TimerA.a for internal
														// feedback loop with PFM signal no encoder
														// (software reference manual p. 199)

EncTable[18].index1 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 left shift of 32 bit
														// register
														// (software reference manual p. 185)

EncTable[18].index2 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 right shift of 32 bit
														// register
														// (software reference manual p. 188)

EncTable[18].index3 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 derivative
														// (software reference manual p. 191)

EncTable[18].index4 = 0									// Encoder table entry first conversion factor
														// type specific. For type 1 integrations if index2
														// > 32
														// (software reference manual p. 193)

EncTable[18].MaxDelta = 0								// Encoder table entry maximum legal output change
														// type specific. For type 1 if derivative limiting
														// is enabled. .MaxDelta=0 disabled
														// (software reference manual p. 197)

EncTable[18].ScaleFactor = 1/256							// Encoder table entry output scale factor
														// type 1: (single-word read): After the two shifting
														// operations specified by index2 and index1, the LSB 
														// of the actual data is typically in Bit (32 minus 
														// number of bits) of the 32-bit word. Since most users
														// want the output to be in units of LSBs of actual
														// data, this intermediate result must be multiplied
														// by 2-(32-[# of bits]). For example, if there were
														// 20 bits of real data, ScaleFactor should be set to
														// 2-(32-20), or 2-12, which is 0.00244140625.
														// (software reference manual p. 205)
														// To get the output of the conversion table in units
														// of encodre counts (most common),
														// EncTable[n].ScaleFactor should be set to 1/256 with 
														// encoder and 1.0 without encoder
														// (ACC24E reference manual p. 36 and 114)

//Motor Control

Motor[18].Ctrl=Sys.ServoCtrl							// Pointer to selected servo loop algorithm
													// default .Ctrl=Sys.ServoCtrl standard PID
													// Sys.PidCtrl very simple but fast
													// Sys.AdaptiveCtrl adaptive PID
													// Sys.PosCtrl just positon output no PID
													// (software reference manual p. 370)

Motor[18].PhaseCtrl=0								// Control flag to activate commutation tasks,
													// default=0 range 0to15
													// .PhaseCtrl=0 no phase commutation for steppers
													// (software reference manual p. 422)

Motor[18].ServoCtrl=1								// Control flag to activate servo tasks
													// default=0 range 0to15
													// .ServoCtrl=1 standard servo mode
													// (software reference manual p. 447)

Motor[18].pDac=Gate3[4].Chan[3].Pfm.a				// Command output pointer
													// (software reference manual p. 417)

Motor[18].pAmpFault=Gate3[4].Chan[3].Status.a		// Amplifier-fault (input) flag pointer
													// default=0 disabled
													// pAmpFault = Gate3[m].Chan[n].Status.a to use
													// (software reference manual p. 410)


Motor[18].AmpFaultLevel=1							// Amplifier-fault level
													// default=0
													// needs to be 1 so that high indicates fault

Motor[18].pAmpEnable=Gate3[4].Chan[3].OutCtrl.a		// Amplifier-enable (output) flag pointer
													// .pAmpEnable=Gate3[4].Chan[3].OutCtrl.a use 
													// .pAmpEnable=1 enable always
													// (software reference manual p. 409)

Motor[18].pLimits = 0								// Overtravel limit (input) flag pointer
													// .pLimits = Gate3[4].Chan[3].Status.a use flags
													// .pLimits = 0 disable flags
													// (software reference manual p. 433)

Motor[18].pCaptFlag = Gate3[4].Chan[3].Status.a		// Encoder capture trigger (input) flag pointer
													// (software reference manual p. 415)

Motor[18].pCaptPos = Gate3[4].Chan[3].HomeCapt.a		// Encoder captured position pointer
													// (software reference manual p. 415)

Motor[18].pEnc = EncTable[18].a						// Outer (position) loop position feedback pointer
													// (software reference manual p. 418)

Motor[18].pEnc2 = EncTable[18].a						// Inner (velocity) loop position feedback pointer
													// (software reference manual p. 418)
													              
// Motor PID servo setup

Motor[18].Servo.Kp = 10000					// PID proportiona term		
Motor[18].Servo.Ki = 0.1				// PID integral term
Motor[18].Servo.Kvfb= 0					// PID velocity feedback (“derivative”) gain term
Motor[18].Servo.Kvff = 0

Motor[18].Servo.BreakPosErr = 500.0		// Servo gain-break error size (deadband)
Motor[18].Servo.Kbreak = 0				// Servo “gain break” relative gain within this dead band

Motor[18].Servo.MaxPosErr= 1000000.0		// Servo-error input magnitude limit

// Motor Speeds

Motor[18].JogSpeed=10					// Jog command velocity magnitude
										// mu / millisecond
										
Motor[9].MaxSpeed=10

Motor[18].HomeVel=10

Motor[18].JogTa=-200						// Jog accel/decel time or inverse rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^2
										// -200 -> 0.005 mu/ms^2 -> 5m/s^2 or 0.5g

Motor[18].JogTs=-1000					// Jog accel/decel S-curve time or inverse jerk rate
										// > 0 mu / millisecond
										// < 0 mu / millisecond^3
										// -50 -> 0.02m/s^3
										// -12500 -> 0.00008 mu/ms^3 -> 80m/s^3 -> 80g/s
										
Motor[18].FatalFeLimit=1000000
Motor[18].WarnFeLimit=800000
Motor[18].MaxDac=5000000
										

Motor[18].BlSize=0						// Backlash size

Motor[18].BlSlewRate =0.0				// Backlash take-up rate

Motor[18].HomeOffset=0.0					// Position referencing offset	


// Coordinate system

&18									// Address C.S. 1

#18->1X							// Assign motor to CS and define scale
									// X, Y, Z,.... linear
									// A, B, C, AA, BB, CC .... rotary

//Coord[18].PosRollOver[0]=18000		// Axis position rollover range for rotary only
									// in axis units!!!! default=0.0 disabled
									// .PosRollOver[0] for axis A
									// .PosRollOver[1] for axis B ...
									// 360 -> shortest path in abs move
									// -360 -> use commanded direction in abs move
									
									//Encoder Conversion Table

Acc84E[5].SerialEncCtrl=$63000B
Acc84E[5].Chan[0].SerialEncCmd=$2114A0	// 32 bit 2bit status and 6bit polynom Biss C encoder
Acc84E[5].Chan[1].SerialEncCmd=$2114A0
Acc84E[5].Chan[2].SerialEncCmd=$2114A0
Acc84E[5].Chan[3].SerialEncCmd=$2114A0

EncTable[19].type=2;        // 24+8 bit read entry;
EncTable[19].pEnc = Acc84E[5].Chan[0].SerialEncDataA.a   // address of lower 24 bit
EncTable[19].pEnc1 = Acc84E[5].Chan[0].SerialEncDataB.a  // address of upper 8 bits
EncTable[19].index1 = 0;									// left shift for sign adjustment 32-26=6
EncTable[19].index2 = 0;
EncTable[19].index3 = 0;
EncTable[19].index4 = 0;
EncTable[19].ScaleFactor =   1//  1/exp2(32)*360.;    // scale back to offset the left adjustment done by index2
EncTable[19].MaxDelta = 50000 * 256;


EncTable[20].type=2;        // 24+8 bit read entry;
EncTable[20].pEnc = Acc84E[5].Chan[1].SerialEncDataA.a   // address of lower 24 bit
EncTable[20].pEnc1 = Acc84E[5].Chan[1].SerialEncDataB.a  // address of upper 8 bits
EncTable[20].index1 = 0;									// left shift for sign adjustment 32-26=6
EncTable[20].index2 = 0;
EncTable[20].index3 = 0;
EncTable[20].index4 = 0;
EncTable[20].ScaleFactor =   1//  1/exp2(32)*360. //1/exp2(32-SingleTurnRes);    // scale back to offset the left adjustment done by index2
EncTable[20].MaxDelta = 50000 * 256;

EncTable[21].type=2;        // 24+8 bit read entry;
EncTable[21].pEnc = Acc84E[5].Chan[2].SerialEncDataA.a   // address of lower 24 bit
EncTable[21].pEnc1 = Acc84E[5].Chan[2].SerialEncDataB.a  // address of upper 8 bits
EncTable[21].index1 = 0;									// left shift for sign adjustment 32-26=6
EncTable[21].index2 = 0;
EncTable[21].index3 = 0;
EncTable[21].index4 = 0;
EncTable[21].ScaleFactor =  1// 1/exp2(32)*360. //1/exp2(32-SingleTurnRes);    // scale back to offset the left adjustment done by index2
EncTable[21].MaxDelta = 50000 * 256;

EncTable[22].type=2;        // 24+8 bit read entry;
EncTable[22].pEnc = Acc84E[5].Chan[3].SerialEncDataA.a   // address of lower 24 bit
EncTable[22].pEnc1 = Acc84E[5].Chan[3].SerialEncDataB.a  // address of upper 8 bits
EncTable[22].index1 = 0;									// left shift for sign adjustment 32-26=6
EncTable[22].index2 = 0;
EncTable[22].index3 = 0;
EncTable[22].index4 = 0;
EncTable[22].ScaleFactor =  1// 1/exp2(32)*360. //1/exp2(32-SingleTurnRes);    // scale back to offset the left adjustment done by index2
EncTable[22].MaxDelta = 50000 * 256;

 
EncTable[23].type=8
EncTable[23].pEnc = EncTable[19].PrevEnc.a   // address of lower 24 bit
EncTable[23].pEnc1 = EncTable[22].PrevEnc.a  // address of upper 8 bits
EncTable[23].index1 = 0;									// left shift for sign adjustment 32-26=6
EncTable[23].index2 = 0;
EncTable[23].index3 = 0;
EncTable[23].index4 = 0;
EncTable[23].ScaleFactor = 1/2 ;

EncTable[24].type=8
EncTable[24].pEnc = EncTable[20].PrevEnc.a   // address of lower 24 bit
EncTable[24].pEnc1 = EncTable[21].PrevEnc.a  // address of upper 8 bits
EncTable[24].index1 = 0;									// left shift for sign adjustment 32-26=6
EncTable[24].index2 = 0;
EncTable[24].index3 = 0;
EncTable[24].index4 = 0;
EncTable[24].ScaleFactor = 1/2 ;

EncTable[25].type=8
EncTable[25].pEnc = EncTable[23].PrevEnc.a   // address of lower 24 bit
EncTable[25].pEnc1 = EncTable[24].PrevEnc.a  // address of upper 8 bits
EncTable[25].index1 = 0;									// left shift for sign adjustment 32-26=6
EncTable[25].index2 = 0;
EncTable[25].index3 = 0;
EncTable[25].index4 = 0;
EncTable[25].ScaleFactor = 1 ;

//////////////////////////////////////////////////////////////////////////////////////////////////////
// 
/////////////////////////////////////////////////////////////////////////////////////////////////////
&0

Sys.WpKey=$0 // Write-protect Gate3 registers			// disabling writing to hardware registers


 
